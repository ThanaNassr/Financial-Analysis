# -*- coding: utf-8 -*-
"""Assignment2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wgReOKc6smLTIjC-qDwNxHbDUPIW1FbU
"""

# 1️⃣ Install the required library (run this only once or run in console if you are using Spyder or Pycharm)
!pip install yfinance
# 2️⃣ Import the yfinance package
import yfinance as yf
# 3️⃣ Download the historical price data for Solana (SOL) and Bitcoin (BTC)
# collect daily data between 1 January 2022 and the current date (the day when you are doing the assignment)
# Download Solana data
sol = yf.download("SOL-USD", start="2022-01-01", end="2025-10-15")
# Download Bitcoin data
btc = yf.download("BTC-USD", start="2022-01-01", end="2025-10-15")
# 4️⃣ Inspect the first few rows of each dataset
print("Solana Data:")
print(sol.head())
print("\nBitcoin Data:")
print(btc.head())

#TASK 1
#Use the date range from January 1, 2022, to current date
# Download Solana data
import pandas as pd
sol = yf.download("SOL-USD", start="2022-01-01", end="2025-12-20")
# Download Bitcoin data
btc = yf.download("BTC-USD", start="2022-01-01", end="2025-12-20")

# Flatten yfinance MultiIndex columns - for later
if isinstance(sol.columns, pd.MultiIndex):
    sol.columns = sol.columns.get_level_values(0)

if isinstance(btc.columns, pd.MultiIndex):
    btc.columns = btc.columns.get_level_values(0)

#Display the first 8 rows of each DataFrame (one for SOL and one for BTC
print("Solana (SOL) – first 8 rows:")
print(sol.head(8))

print("\nBitcoin (BTC) – first 8 rows:")
print(btc.head(8))
#Print the shape (total rows and columns) of both datasets
print("Solana (SOL) dataset shape:")
print(sol.shape)

print("\nBitcoin (BTC) dataset shape:")
print(btc.shape)

# Print the names of all columns in each DataFrame and describe what each column likely represents
print("Solana (SOL) columns:")
print(sol.columns)

print("\nBitcoin (BTC) columns:")
print(btc.columns)

"""1. What the shape tells us :
- how big the datset is and how much the data is for analysis



2. Likely meaning o fthe columns :

Open: The price of the cryptocurrency at the start of the trading day.

High: The highest price reached during the trading day.

Low: The lowest price reached during the trading day.

Close: The price at the end of the trading day.

Adj Close (Adjusted Close): The closing price adjusted for events such as splits or dividends. For cryptocurrencies, this is often the same as the closing price.

Volume: The total number of units traded during the day.

"""

# TASK 2 - Descriptive Statistics
#Calculate basic statistics
# Select the relevant price columns
price_cols = ['Open', 'High', 'Low', 'Close']

# Calculate statistics for Solana
sol_stats = sol[price_cols].agg(['mean', 'median', 'min', 'max', 'std'])

# Calculate statistics for Bitcoin
btc_stats = btc[price_cols].agg(['mean', 'median', 'min', 'max', 'std'])

print("Solana (SOL) price statistics:")
print(sol_stats)

print("\nBitcoin (BTC) price statistics:")
print(btc_stats)

#Compute the correlation matrix for the numerical columns
# Select numerical columns
num_cols = ['Open', 'High', 'Low', 'Close', 'Volume']

# Correlation matrix for Solana
sol_corr = sol[num_cols].corr()

print("Solana (SOL) correlation matrix:")
print(sol_corr)

# Correlation matrix for Bitcoin
btc_corr = btc[num_cols].corr()

print("\nBitcoin (BTC) correlation matrix:")
print(btc_corr)


# Identify potential outliers in the 'High' and 'Low' prices using the IQR (Interquartile Range) rule.
#Print the number of outliers found in each dataset and suggest why they might occur

def count_outliers_iqr(series):
    Q1 = series.quantile(0.25)
    Q3 = series.quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR

    outliers = series[(series < lower_bound) | (series > upper_bound)]
    return len(outliers)

sol_high_outliers = count_outliers_iqr(sol['High'])
sol_low_outliers = count_outliers_iqr(sol['Low'])

print("\nSolana (SOL) outliers:")
print(f"High price outliers: {sol_high_outliers}")
print(f"Low price outliers: {sol_low_outliers}")

btc_high_outliers = count_outliers_iqr(btc['High'])
btc_low_outliers = count_outliers_iqr(btc['Low'])

print("\nBitcoin (BTC) outliers:")
print(f"High price outliers: {btc_high_outliers}")
print(f"Low price outliers: {btc_low_outliers}")

#TASK 3 - Visualization and Time-Based Aggregation

#Using Matplotlib or Pandas plotting, create line plots for 'Open' , 'High' , 'Low' , and 'Close' prices over time for both SOL and BTC.
import matplotlib.pyplot as plt

# Plot SOL prices
plt.figure()
plt.plot(sol.index, sol['Open'], label='Open')
plt.plot(sol.index, sol['High'], label='High')
plt.plot(sol.index, sol['Low'], label='Low')
plt.plot(sol.index, sol['Close'], label='Close')

plt.title('Solana (SOL) Prices Over Time')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.legend()
plt.show()

# Plot BTC prices
plt.figure()
plt.plot(btc.index, btc['Open'], label='Open')
plt.plot(btc.index, btc['High'], label='High')
plt.plot(btc.index, btc['Low'], label='Low')
plt.plot(btc.index, btc['Close'], label='Close')

plt.title('Bitcoin (BTC) Prices Over Time')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.legend()
plt.show()


# Resample the data by weekly intervals and calculate the average 'Open' , 'Close' , and 'Volume'
# Display the first 5 rows and discuss observed trends
cols = ['Open', 'Close', 'Volume']
sol_weekly = sol[cols].resample('W').mean()

print("Solana (SOL) weekly averages – first 5 rows:")
print(sol_weekly.head())
btc_weekly = btc[cols].resample('W').mean()

print("\nBitcoin (BTC) weekly averages – first 5 rows:")
print(btc_weekly.head())

# Volume Analysis: - (c.1) Plot 'Volume' over time for both SOL and BTC, identifying spikes above the mean.
import matplotlib.pyplot as plt

sol_mean_vol = sol['Volume'].mean()

plt.figure()
plt.plot(sol.index, sol['Volume'], label='Daily Volume')
plt.axhline(y=sol_mean_vol, linestyle='--', label='Mean Volume')

sol_spikes = sol[sol['Volume'] > sol_mean_vol]
plt.scatter(sol_spikes.index, sol_spikes['Volume'], label='Spikes Above Mean')

plt.title('Solana (SOL) Trading Volume Over Time')
plt.xlabel('Date')
plt.ylabel('Volume')
plt.legend()
plt.show()

btc_mean_vol = btc['Volume'].mean()

plt.figure()
plt.plot(btc.index, btc['Volume'], label='Daily Volume')
plt.axhline(y=btc_mean_vol, linestyle='--', label='Mean Volume')

btc_spikes = btc[btc['Volume'] > btc_mean_vol]
plt.scatter(btc_spikes.index, btc_spikes['Volume'], label='Spikes Above Mean')

plt.title('Bitcoin (BTC) Trading Volume Over Time')
plt.xlabel('Date')
plt.ylabel('Volume')
plt.legend()
plt.show()

#(c.2) Create an overlay plot comparing 'Volume' and 'Close' prices using dual y-axes.
import matplotlib.pyplot as plt

fig, ax1 = plt.subplots()

# Left y-axis: Close price
ax1.plot(sol.index, sol['Close'], label='Close Price')
ax1.set_xlabel('Date')
ax1.set_ylabel('Close Price (USD)')

# Right y-axis: Volume
ax2 = ax1.twinx()
ax2.plot(sol.index, sol['Volume'], label='Volume')
ax2.set_ylabel('Volume')

# Title
fig.suptitle('Solana (SOL): Close Price vs Trading Volume')

# Combine legends
lines1, labels1 = ax1.get_legend_handles_labels()
lines2, labels2 = ax2.get_legend_handles_labels()
ax1.legend(lines1 + lines2, labels1 + labels2)

plt.show()

fig, ax1 = plt.subplots()

# Left y-axis: Close price
ax1.plot(btc.index, btc['Close'], label='Close Price')
ax1.set_xlabel('Date')
ax1.set_ylabel('Close Price (USD)')

# Right y-axis: Volume
ax2 = ax1.twinx()
ax2.plot(btc.index, btc['Volume'], label='Volume')
ax2.set_ylabel('Volume')

# Title
fig.suptitle('Bitcoin (BTC): Close Price vs Trading Volume')

# Combine legends
lines1, labels1 = ax1.get_legend_handles_labels()
lines2, labels2 = ax2.get_legend_handles_labels()
ax1.legend(lines1 + lines2, labels1 + labels2)

plt.show()

#TASK 4 - Comparative Analysis and Advanced Metrics

# Calculate daily returns for both SOL and BTC using  : daily return = (Close − Open)/Open
# Daily returns for Solana
sol['Daily_Return'] = (sol['Close'] - sol['Open']) / sol['Open']

print("Solana daily returns (first 5 rows):")
print(sol[['Open', 'Close', 'Daily_Return']].head())

# Daily returns for Bitcoin
btc['Daily_Return'] = (btc['Close'] - btc['Open']) / btc['Open']

print("\nBitcoin daily returns (first 5 rows):")
print(btc[['Open', 'Close', 'Daily_Return']].head())
#Returns as percentages
sol['Daily_Return_Pct'] = sol['Daily_Return'] * 100
btc['Daily_Return_Pct'] = btc['Daily_Return'] * 100
#Add them as new columns and compute the mean and standard deviation of daily returns

# Solana statistics
sol_mean_return = sol['Daily_Return'].mean()
sol_std_return = sol['Daily_Return'].std()

# Bitcoin statistics
btc_mean_return = btc['Daily_Return'].mean()
btc_std_return = btc['Daily_Return'].std()

print(f"\nSOL Mean Daily Return: {sol_mean_return * 100:.2f}%")
print(f"SOL Daily Return Std Dev: {sol_std_return * 100:.2f}%")

print(f"BTC Mean Daily Return: {btc_mean_return * 100:.2f}%")
print(f"BTC Daily Return Std Dev: {btc_std_return * 100:.2f}%")

#Plot cumulative returns to measure the overall performance of each cryptocurrency by calculating the cumulative return over time.
#cumulative_return = (1 + Daily_Return).cumprod() - 1
# Cumulative returns for Solana
sol['Cumulative_Return'] = (1 + sol['Daily_Return']).cumprod() - 1

# Cumulative returns for Bitcoin
btc['Cumulative_Return'] = (1 + btc['Daily_Return']).cumprod() - 1

plt.figure()
plt.plot(sol.index, sol['Cumulative_Return'], label='SOL Cumulative Return')
plt.title('Solana (SOL) Cumulative Return Over Time')
plt.xlabel('Date')
plt.ylabel('Cumulative Return')
plt.legend()
plt.show()

plt.figure()
plt.plot(btc.index, btc['Cumulative_Return'], label='BTC Cumulative Return')
plt.title('Bitcoin (BTC) Cumulative Return Over Time')
plt.xlabel('Date')
plt.ylabel('Cumulative Return')
plt.legend()
plt.show()
#Compute the rolling 30-day volatility &  Plot the rolling volatility of both cryptocurrencies on a single graph

# 30-day rolling volatility
sol['Rolling_30D_Volatility'] = sol['Daily_Return'].rolling(window=30).std()
btc['Rolling_30D_Volatility'] = btc['Daily_Return'].rolling(window=30).std()


plt.figure()
plt.plot(sol.index, sol['Rolling_30D_Volatility'], label='SOL 30-Day Volatility')
plt.plot(btc.index, btc['Rolling_30D_Volatility'], label='BTC 30-Day Volatility')

plt.title('30-Day Rolling Volatility of Daily Returns')
plt.xlabel('Date')
plt.ylabel('Rolling Volatility (Std Dev of Returns)')
plt.legend()
plt.show()